# -*- coding: utf-8 -*-
"""FCNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K4UldSKZBE0QE7kNuKhcR-RGEINRMnMP
"""

import torch
X = torch.Tensor([
                  [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
                  [[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1]],
                  [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],
                  [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,1]],
])

import matplotlib.pyplot as plt

for i in range(4):
    plt.imshow(X[i])
    plt.show()

y = torch.tensor([0, 1, 2, 3])
y

classes = {
    0: 'L',
    1: 'O',
    2: 'V',
    3: 'E',
}

"""## DEfine Model"""

import torch.nn as nn
import torch.nn.functional as F

class FCNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(25, 32)    # 32 is the hidden layer's dim
        self.fc2 = nn.Linear(32, 64)
        self.fc3 = nn.Linear(64, 4)

    def forward(self, x):
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

net = FCNN()

net(X.view(-1, 25))

"""## Train Model"""

loss_fn = nn.CrossEntropyLoss()

import torch.optim as optim

optimizer = optim.Adam(net.parameters(), lr=0.01)

epochs = 100

losses = []
for epoch in range(epochs):
    optimizer.zero_grad()
    outputs = net(X.view(-1, 25))
    loss = loss_fn(outputs, y)
    loss.backward()
    optimizer.step()
    losses.append(loss)

t = torch.Tensor([1])
print(t)
print(type(t))
print(type(t[0]))
print(t[0].type)
t = torch.Tensor([1])
print(t.type)

import matplotlib.pyplot as plt

plt.plot(losses)
plt.show()

