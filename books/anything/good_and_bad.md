## sec 1
設計をないがしろにするとどんな弊害が起こるか

- コードを読み解くのに時間がかかる
- バグを埋め込みやすくなる
- 悪しき構造がさらに悪しき構造を誘発する

### 悪しき構造
- 意味不明な命名
    - 技術ベースでの命名（技術駆動命名）を避ける
        - Memory, Flag,
    - 連番命令
        - method001, method002, ...
    - ドキュメントはすぐ嘘をつく
- 悪魔を招きやすいデータクラス
    - 設計が不十分なソフトウェアで頻繁に登場するクラス構造
    - 関連するデータやロジック同士が分散し、バラバラになる
        - **低凝集**
- 低凝集の問題点
    - 重複コード
    - 修正もれ
    - 可読性低下
    - 未初期化状態（生焼けオブジェクト）
        - 初期化知らないと使い物にならないクラス！
    - 不正値の混入

## sec 2
``` java
class HitPoint {
    private static final int MIN = 0;
    private static final int MAX = 999;
    final int value;
    
    HitPoint(final int value) {
        if (value < MIN) throw new IllegalArgumentException(MIN + "以上を指定してください");
        if (value > MAX) throw new IllegalArgumentException(MAX + "以下を指定してください");

        this.value = value;
    }

    HitPoint damage(final int damageAmount) {
        final int damaged = value - damageAmount;
        final int corrected = damaged < MIN ? : MIN : damaged;
        // value を final ではなく可変にして、n既存インスタンスの値を書き換える方法だと、何がまずい？
        return new HitPoint(corrected);
    }

    HitPoint recover(final int recoveryAmount) {
        final int recovered = value + recoveryAmount;
        final int corrected = MAX < recovered ? MAX : recovered;
        return new HitPoint(corrected);
    }
}
```


## sec 3
保守や変更がしやすいコードには、関心の分離が重要！

データクラスは悪魔が潜みがち

### 守るべきこと
クラス設計とは、インスタンス変数を不正状態に陥らせないためのしくみづくりといっても過言ではない！！

- クラス単位で正常に動作するように設計する
    - クラスの構成要素
        - インスタンス変数
        - メソッド
    - 良いクラスの構成要素
        - インスタンス変数
        - インスタンス変数を不正状態から防御し、正常に操作するメソッド
    - 単なるデータクラスはこの設計から外れている
    - クラスに自己防衛責務を持たせるべき！
- 値の変更が必要な場合は新しいインスタンスを作成する
- 引数に final をつける
    - メソッド引数やローカル引数
    - 思わぬ副作用の防止
- 値の渡し間違い、を型で防止する！
    - int,string 等のプリミティブ型ではなく、Money 型どうしで加算させるなど
    - プリミティブ型に固執しない
- 高凝集にこだわる
- データとそれを操作するロジックを１つのクラスにまとめ、必要な手続きのみを外部に公開する
    - カプセル化

### 設計パターン
- 完全コンストラクタ
- 値オブジェクト
- ストラテジ
- ポリシー
- ファーストクラスコレクション
- スプラウトクラス


## sec 4
可変と不変を適切に設計しないと、挙動の予測が困難になるので、変更を最小限にする設計が重要。

### memo
- 再代入を防ぐ
    - 上書きをせずに別の変数を用意すべき
    - final をつけて不変にする
- 状態の変更
    - インスタンス変数の変更
    - グローバル変数の変更
    - 引数の変更
    - ファイルの読み書きなどの I/O 操作
- 副作用
    - 関数が引数を受け取り戻り値を返す以外に、外部の状態を変更すること
    - オブジェクト指向プログラミング言語では、副作用のない関数を厳密に作り込むスタイルよりも、クラスのスコープ内で影響を閉じ込めるスタイルが一般的
- デフォルトは不変
    - Java は final 修飾子が必要なので多少冗長になる
    - Kotlin, Scala では val, var から val の選択
    - JS は const を選ぶ
    - Rust では不変がデフォルト（mut をつけて可変にする必要がある）
    - 近年の言語ほど普遍を導入しやすい
        - 不変の重要性が増している！
- いつ可変にするか
    - パフォーマンスを気にするとき
        - 毎回インスタンスを生成しているので
- コードが意図のやりとりは局所化する
    - リポジトリパターン
        - データベースの永続化処理をカプセル化する設計パターン


## sec 5
凝集度とは、「モジュール内における、データとロジックの関係性の強さを表す指標」

### ダメなパターン
- static メソッド
    - 低凝集を引き起こしがち
    - インスタンス変数を全く使わない、インスタンスメソッドのフリをしたメソッドにも注意！
        - 試しに static をつけてみて、IDE に怒られなかったらビンゴ
    - グローバル変数が出現しやすくなる悪影響！
- WHY static?
    - C 言語などの手続き方の言語では、データトロ軸が別々になる
    - この考えのままオブジェクト指向言語で設計すると別々のクラスになる
- WHEN static?
    - 凝集度に影響がない場合！
        - ログ出力用メソッド
        - フォーマット変換用メソッド
- 初期化のロジックが分散してしまう問題！
    - 対象ごとに入会時のボーナスポイントを振り分ける場合など
        - 呼び出しがわで Point(1000), Point(3000) などとするのはアンチパターン
    - コンストラクタを private にして、目的別のファクトリメソッドを用意
        - 初期化ロジックも凝集させる！

``` java
class GiftPoint {
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;
    final int value;

    private GiftPoint(final int point) {
        if (point < MIN_POINT) {
            throw new IllegalArgumentException("ポイントが0以上ではありません。");
        }

        value = point;
    }

    static GiftPoint forStandardMembership() {
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }
    ...
}
```

- Common, Util クラス
    - 例えば消費税を計算するための共通処理クラスなど、これも低凝集を招くのでアウト！
        - 税込金額クラスを作る
            - うーん
            - AmountIncludingTax
    - 根本的な原因は、共通化や再利用性に関して理解が不足していること、
    - 共通処理クラスを容易に作らない！
- 横断的関心ごと
    - 共通処理とまとめても良い
    - れい
        - ログ出力
        - エラー検出
        - デバッグ
        - 例外処理
        - キャッシュ
        - 同期処理
        - 分散処理
- 引数が多いのは悪いこと
    - 処理内容が増えると、ロジックが複雑化したり悪魔が現れる
    - **プリミティブ型執着**
    - 引数が多い場合は、データを引数として扱うのではなく、そのデータをインスタンス変数としてもつクラスへ設計してみるのもよし！
- デメテルの法則！
    - **利用するオブジェクトの内部を知るべきではない**
        - メソッドチェインで内部詳細を渡り歩くのはダメ！
    - 知らない人に話しかけるな
    - **Tell, Don't Ask.**
        - インスタンス変数を private にする
        - 仕様変更に強い


## sec 6
条件分岐をずさんに扱うな！

### アンチパターン
- 条件分岐のネストによる可読性低下
    - 早期 return
        - 条件ロジックと実行ロジックの分離
    - else 句はどうにかできないか注意
- switch 文は悪魔を呼び寄せやすい
    - 同じ条件式の switch 文が複数実装されがち
        - 修正もれ
        - 開発生産性低下
- 単一責任選択の原則
    - ソフトウェアシステムが選択肢を提供しなければならない時、そのシステムの中の１つのモジュールだけがその選択肢の全てを把握すべきである！
    - 同じ条件式の条件分岐を複数か数、一箇所にまとめよう
- interface を使う
    - 分岐ロジックを書かずに分岐と同じことが実現可能に！
- interface を switch 文重複に応用（ストラテジパターン）
    - interface に切り出す
    - Map を使う

``` java
final Map<MagicType, Magic> magics = new HashMap<>();

final Fire fire = new Fire(member);
final Shiden shiden = new Shiden(member);

magics.put(MagicType.fire, fire);
magics.put(MagicType.shiden, shiden);

void magicAttack(final MagicType magicType) {
    final Magic usingMagic = magics.get(magicType);
    usingMagic.attackPower();
}
...
```

**複数同じ switch 文を書こうとしてたら、一旦 interface で切り出せないか考えてみる！**


- ポリシーパターン

``` java
class GoldCustomerPolicy {
    private final ExcellentCustomerPolicy policy;

    GoldCustomerPolicy() {
        policy = new ExcellentCustomerPolicy();
        policy.add(new GoldCustomerPurchaseAmountRule());
        policy.add(new PurchaseFrequencyRule());
        policy.add(new ReturnRateRule());
    }

    boolean complyWithAll(final PurchaseHistory history) {
        return policy.complyWithAll(history)
    }
}
```

- リスコフの置換原則
    - 基本型を継承型に置き換えても問題なく動作しなければならない！
- interface をうまく使いこなせるかが、設計スキルの分水嶺！！
    - 分岐を書きそうになったら、まず interface 設計！
- フラグ引数
    - 内部で処理を切り替えているので、読み手にわかりにくい
    - メソッドは単機能にすべき！
        - そうするとフラグとかいってられなくなる


## sec 7
コレクション：ネストを解消する構造化技法

### Memo
- 車輪の再発明
    - 例：anyMatch を使わず自前で実装してしまう
        - members.stream().anyMatch(each -> each.id == member.id)
    - すでにあるものよりも役に立たないものを作り出すこと
        - 四角い車輪の再発明。。。
    - フレームワークの機能やライブラリを丁寧に調査することが重要
- コレクション処理は、気をつけないとあちこちに分散される
- ファーストクラスコレクション
    - コレクション処理をカプセル化する
- 外部へ渡す場合はコレクションを変更できなくする
    - せっかくクラスに集めて高凝集したのに、逆戻りする恐れ
    - members.unmodifiableList()


## sec 8
密結合とは、「モジュール間の、依存の度合いを表す指数」

責務と切っても切り離せない話題、「ある関心ごとについて、正常に動作するよう制御する責任」

### メモ
- DRY 原則の誤用
    - 夏季割引と通常割引で同じロジックがあるからといって、それをまとめるのは避ける！
    - 責務を考えずに無理にひとまとめにしても、責務が多重になり破綻する！
        - 後から夏季割引だけ 5% 割引とかに変更するケースも多々ある
- DRY 原則
    - すべての知識はシステム内において、単一、かつ明確な、そして信頼できる表現になってなければならない
    - 知識をここではビジネス知識、とする
    - 通常割引と夏季限定割引は、それぞれ別の概念！
        - DRY にすべきは、それぞれの概念単位
- 継承に絡む密結合！
    - 継承はかなり注意して扱わないと、すぐ密結合になる
    - 継承は本書では、よっぽどのことがない限り**推奨していない！！！**
- スーパークラス依存
    - サブクラスは、スーパークラスの構造をいちいち気にしなければならない
    - スーパークラスの変更によりバグ化してまう！
    - また、スーパークラスはサブクラスを気にせず変更されてく！
- **継承より委譲**
    - 委譲とはコンポジション構造にすること
    - 利用したいクラスをスーパークラスとして継承するのではなく、private なインスタンス変数としてもつ
- 影響スケッチ
    - [Jig](https://github.com/dddjava/jig) などを使うと、ソースコードから解析して描画してくれる！
- private メソッドばかりも要注意
    - 単一責任じゃなくなってる可能性大！
    - 異なる責務のロジックが private メソッドとして実装されているケース
        - 別々のクラスに分離すべし
- **高凝集を意図した結果密結合に陥るパターン**
    - 疎結合高凝集を目指したいよねー
- スマートUI
    - 表示関連のクラスの中に、表示以外の責務のロジックが実装されてしまっている
- 巨大データクラス
    - あらゆるユースケースで使われるようになり、グローバル変数の性質を帯びてしまう


## sec 9

### memo
- YAGNI
- マジックナンバー
- 文字列型執着
- グローバル変数
    - public static
    - グローバル変数を参照しているロジックに変更を加える際、慎重な検討が必要
        - 排他制御等
    - グローバル変数と同等のもの（巨大データクラス等）にも注意
- null 問題
    - null が入り込む前提でロジックを組むと、至る所で null チェックが必要
        - 見通も悪くなるし、チェック漏れがそくバグにつながる
    - null ?
        - 未定義状態のメモリ領域へのアクセスは、制御上のトラブルの原因になる
        - こうした事態を避けるためのもの
        - null は最低限メモリアクセストラブルを防止するための仕組みであって、null 自体は無効な扱い！
    - **何も持っていない状態や未設定状態も、立派な状態！！**
        - それ等に null を使わない！！！
        - その状態すら存在していないのが null
    - null を返さない、渡さない
- 例外の握りつぶしはダメえ
    - 原因分析困難に陥り開発者を疲弊させる
- メタプログラミングの用途は限定する！
    - プログラム構造自体を制御するプログラミング
    - Java ではクラス構造を読み書きできる機構の、リフレクションが用意されている
    - 型の強みを活かせなくなるハードコード！
- 技術駆動パッケージングは関係が見えにくい
    - MVC などはこの分け方
    - ビジネス概念として強く関係し合うもの同士が一緒になる方が良い
        - パッケージプライベートの強みが活かせる
        - 変更を追うのが楽


## sec 10
適切な責務を考え、密結合を防止するには、クラスやメソッドへの名前づけ、すなわち命名も重要なポイント！

名前に注意を払い、名前とロジックを対応づけること！

### **目的駆動名前設計**を目指す。
- 関心ごとにふさわしい命名
    - 影響範囲の低減 ⇨ 開発生産性の向上
    - 目的不明オブジェクトとなるような、抽象的ないい加減な名前は避ける
        - あっという間に巨大化してしまう
        - 商品 ⇨ 注文品、予約品、在庫品、発送品
- 命名ではなく、名前設計！
    - 名前の役割は、可読性を高めること**だけではない**
    - 関心ごとの分離を意識し命名づけることは、疎結合高凝集につながる
- ポイント
    - 存在ベースではなく、目的ベースで考える
    - 声に出して読んでみる
    - 利用規約を読んでみる
- 仕様変更時の、意味範囲の変化に注意
- 会話に登場するのにコードに登場しない名前に注意
    - 形容詞を使って区別の仕方を説明し出したら注意！
        - 形容詞をつけてまで違いを表したいものは、それぞれクラスとして設計するべし
- 構造を大きく歪ませてしまう名前
    - xxxInfo, xxxData などは、「データだけのクラスなんだ」と印象付けてしまうので、避ける
    - DTO は例外
        - 参照系でのみの用途
- 動詞 + 目的語、のメソッド名に注意
    - 無関係な責務のメソッドを追加しやすくしている
        - 実装を急いでる時や、既存のクラスだけでなんとか動くよう無理に実装しようとした時、こうなりがち
    - 可能な限り動詞１語で住む名前にする！
        - そのようなクラス設計
    - 目的語の概念を表現するクラス + その動詞
- boolean を返すメソッド
    - クラス名 is 状態、で綺麗に読める設計か？


## sec 11
保守と変更の正確性を高めるコメントの書き方

### memo
- コメントはメンテされにくい、という性質を覚えておく！
    - コメントは簡単に嘘をつく
    - **退化コメント**
- コメントは劣化コピーに過ぎないことを理解する！
- ロジックの挙動をなぞるだけのコメントは退化しやすい

``` java
class Member {
    private final States states;

    // 苦しい状態の場合trueを返す。
    boolean isPainful() {
        // 今後仕様変更で状態異常による表情変化が追加される場合、
        // 本メソッドへロジック追加すること。
        if (states.contains(StateType.poison) ||
            states.contains(StateType.paralyzed)) {
            return true;
        }

        return false;
    }
}
```

- Rule
    - ロジック変更時、同時に必ずコメントも変更する
    - ロジックの内容をなぞるだけのコメントをしない
    - 可読性の悪いロジックを捕捉するようなコメントはダメ
        - ロジックの可読性を高めよ
    - ロジックの意図や仕様変更時の注意点をコメントする！
- ドキュメントコメント
    - Java では Javadoc
    - API ドキュメントを自動生成


## sec 12
良きクラスには良きメソッドあり

### メモ
- 必ず自身のクラスのインスタンス変数を使うこと！
- getter/setter
    - 「よそのクラスを気にしたりいじったいするメソッド構造」に陥りやすい
    - 尋ねるな、命じろ！
    - これはカプセル化ではない！！
        - カプセル化とは、データとそのデータを操作するロジックを１つのクラスにまとめ、必要な手続きのみを外部へ公開すること
- コマンド・クエリ分離（CQS）
    - メソッドはコマンド（変更）またはクエリ（問い合わせ）のどちらかだけを行うこと
- 引数
    - 不変にする
    - フラグ引数は使わない
    - null を渡さない
        - null に意味を持たせないようにする！
- 返り値
    - null を返さない
    - エラーは戻り値で返さない、例外をスローすること
        - -1 を返すなど
        - ダブルミーニングであり、呼び出し側が実装を知っている必要がある


## sec 13
- モデル：物事の特徴や関係性を図示したもの
- モデリング：モデルを作る活動

### memo
- 邪悪な構造に陥りがちな User クラス
- モデルはシステム構造の説明のために用いる
    - システムは目的達成のための手段
    - 特定の目的達成のために最低限考慮が必要な要素を備えたものがモデル！！！
- モデルの一貫性を保つ
    - User クラスなどは爆発して一貫性が取れなくなりがち
    - **モデリングには、対象とする社会的活動や目的の理解が必要**
- 単一責任とは単一目的
    - クラスが果たす目的は、たったひとつに限定すべき
    - 特定の目的に特化して設計することで、変更に強い高品質な構造になる
        - クラスというと「共通利用可能な、汎用的な部品として設計するもの」と捉えられがちだが逆！
    - 責務、と言われてピンとこない場合は、目的から考える
- モデル=クラスは必ずしも成り立たない
    - モデルは１個または複数のクラスから構成


## sec 14
リファクタリング

### memo
- リファクタリングにはユニットテストが必須！
- IDE
    - Refactor -> Extract method
- 機能追加とリファクタリングを同時にやらない！
- スモールステップで実施する


## sec 15
保守性の中でも特に、変更容易性の向上を目的にした設計手法を扱ってきた

### memo
- レガシーコード
    - 変更が困難で壊れやすいコード
    - レガシーコードの蓄積している状態を技術的負債と呼ぶ
- 木こりのジレンマと同じことが、ソフトウェア開発でも起こってしまう
- 一生懸命仕事した感覚だけが残って生産性は悪いまま
- 技術的負債の経済的損失は、日本で 12 兆円
- 変更容易性を高めることは、ソフトウェアの成長性を高めること
    - 変更容易性が悪化すると、ソフトウェアの成長性や自身のスキルの成長性も悪化する
- エンジニアにとっての資産とは何か
    - **技術力に他ならない**
    - しかし、レガシーコードは資産の蓄積、すなわち技術力の成長を妨げてしまう恐ろしい存在
- コードの良し悪しを判断する指標
    - コードメトリクス（ソフトウェアメトリクス）
    - e.g. コード行数の上限
        - メソッド：10行以内
        - クラス：100行以内
    - e.g. 循環的複雑性
    - e.g. 凝集度
        - LCOM などのメトリクスで計測可能
    - e.g. 結合ど
- コード分析をサポートするツールたち〜
    - Code Climate Quality
    - Understand
- 費用対効果を高くせな
    - パレートの法則
- コアドメイン
    - サービスのウリとなるビジネス領域
    - ドメイン駆動設計は、コアドメインの価値を継続的に高め、サービスを長期的に成長させる設計手法
    - ドメインエキスパートとの協力
    - 構造の良し悪しだけに着目していると、ビジネス戦略上、設計がうまく働かなくなるかも

## sec 16
開発の問題はコード以外にも潜んでいる

### memo
- コミュニケーション
    - コミュニケーションが希薄だと設計品質に問題が生じる
    - コンウェイの法則
        - システムの構造が、それを設計する組織構造に似てくる
        - コミュニケーションコスト構造の法則とも捉えられる
    - 心理的安全
        - ハーバード. 1999 に提唱
        - Google. 2012
- 設計
    - 早く終わらせたいという心理が、品質低下の縄
    - 粗悪なコードはきれいなコードを書くより**常に**遅い
    - クラス設計と実装のフィードバックサイクルを回す
        - 仕様変更の際、最低でもメモ書き程度のクラス図を書く
    - 厳密に設計し過ぎず、サイクルを回し続ける
- パフォーマンス？
    - インスタンス生成にはコストがかかるから、クラスを増やしたくない？
        - 実際はほぼ影響ない
    - 早すぎる最適化、と呼ばれるアンチパターン
        - **ボトルネックがわからないうちから高速に動作するコードを闇雲にかく**
- 既存コードを信用せず、冷静に正体を見破る
    - アンカリング効果に振り回されない
    - **ジョシュアツリーの法則**
        - 名前を知って初めて存在を知覚できるようになる
- コードレビュー
    - **設計的な妥当性に重点を置いてレビューすべき**
    - 敬意と礼儀が大事
- チームで設計を進める上でのプロセス
    - 設計品質に関わるルールや開発プロセスの策定
    - ルールの周知、教育
    - リーダー・マネージャー層への共有
    - 品質の可視化
    - 設計品質の維持


## memo
- 設計に best はありません。常に better を目指しましょう
- 設計は一度やったら終わりではなく、日々繰り返し改良していくことが重要
- 課題とは、理想と現状のギャップ
    - 理想を知っていれば現状と比較ができ、課題がわかる

## 疑問
- sec2, damage で new Instance を返している
    - value を final ではなく可変にして、既存インスタンスの値を書き換える方法だと、何がまずい？
        - 3.2.3(p28) で回答してくれてる
        - インスタンス変数の上書きは、理解を難しくする
        - 変数の値が変わる前提だと、いつ変更されたのか、今の値がどうなっているのかをいちいち気にしなければならない
        - 思わぬ副作用が発生しやすい
    - entity（？）において setter は基本不要ってことか？

## TODO?
- 3章のオブジェクト指向設計を基本に、一つ一つ丁寧にクラス化する
