## 何でも

### Policy as Code

#### ポリシーをコードで定義する。
問題提起：ポリシー自体の品質をどのように維持するか

ポリシーを宣言型の言語を使ってコードとして記述・管理するアプローチ。

メリット

- アップデートやデプロイに対して便利
- バージョン管理システムの利点
- CI/CD によるデプロイの自動化

#### しくみ
Policy as Code を実現するソリューションとして次のようなものがある

- Sentinel
- Open Policy Agent (OPA)

ポリシーエンジン


## js

### 関数
アロー関数の場合は、関数の定義場所で this が静的に決まるので、呼び出し方に左右されない。

例えば、グローバルに定義したアロー関数は、this が必ずグローバルオブジェクトを指す。

アロー関数にはシンプルに arguments がない。

引数名の重複を許していたが、アロー関数は許さない。

アロー関数には、関数名の重複も基本的にはない

アロー関数と関数式は、定義ごに呼び出す必要がある。

#### 使い分け
従来の関数とアロー関数の違いを踏まえ、どちらを使ったほうが良いだろうか。もしどちらも使う場合、どのような基準があるのだろうか。このテーマは議論が尽きず、絶対的に正しい結論がない！

特に理由がない場合、アロー関数が無難。アロー関数は関数としての最低限の機能を持ったシンプルな関数で、細かいことを気にせず書ける利点がある。

とくにコールバック関数に適している

``` javascript
const nums = [1, 2, 3, 4];
const even = nums.filter((n) => n % 2 === 0);
console.log(even);

// 従来の関数とコールバック関数
const even.filter(function (n) {
    return n % 2 === 0;
});
```

### 引数
引数の個数チェックがない。

足りないものは、undefined になる。

#### 値渡しとオブジェクト
オブジェクトの場合は少し特殊で、オブジェクトは値が共有される。


## 関数は第一球オブジェクトである
これは数値や文字列と同様に関数を変数に代入したり関数の引数に渡したりできることを意味する！

#### 値としての関数の挙動
``` javascript
const add = function(x, y) { return x + y; }

console.log(add(3, 4));
console.log(add);
```

#### 関数をオブジェクトのプロパティに入れる
関数が入ったプロパティのことをメソッドという。

#### 即時関数
計算後に sum という変数が残らないのが利点

``` javascript
const arr = [1, 2, 3, 4, 5];

const average = (() => {
    const sum = arr.reduce((a, b) => a + b);
    return sum / arr.length;
})
```

#### 第一級オブジェクトとしての関数を利用する

##### 高階関数の活用
higher-order function,

関数が第一級オブジェクトではない言語であっても似たようなことをするのは不可能ではなく、そのやり方は「Visitor パターン」や「Strategy パターン」などとして知られる。

高階関数に引数で渡した関数は**コールバック関数**と呼ばれる。

### JavaScriptで関数型プログラミングを理解する
関数型プログラミングとは、プログラミングにおけるパラダイムの一つ。しばしば別のパラダイムである「命令型プログラミング」と対比される。

#### 命令型プログラミングとは
命令型プログラミングとは、プログラムを書くときに「how」つまり「何を、どのようにするか」を書いていく考え方やスタイルのこと。

命令型プログラミングにおいては、**文（statement）と式（expression）**が存在する。

文とは、コンピュータが処理する１ステップのことで、if, switch, for, while などがある。

式とは、数字や文字列などのリテラル、変数、関数の呼び出し、あるいは式と演算子の組み合わせのこと。

文と式のうち、命令型プログラミングで重要なのは文の方。

#### 関数型プログラミング
関数型プログラミングは「what」すなわち「何であるか」を記述する。

関数型プログラミングでは全てが式。

関数型で配列の和を求める関数

``` javascript
const sum = (arr) => (arr.length === 0 ? 0 : arr[0] + sum(arr.slice(1)))
```

再帰（recursion）が関数型プログラミングでは重要となる。

どうやって計算すれば良いかという手順を指定する命令型プログラミングとは異なり、関数型プログラミングでは求めるものがなんであるかという定義そのものを宣言しなければならず、そのために再起的な記述が力を発揮する

そして、x === undefined ? 0 のような部分は**基底部（base condition, edge condition）**と呼ばれる。基底部とは、再起的な定義を行うことができないケース。

再起で関数を定義するときは、**問題を同じ構造を持つより小さな問題に再起的に分割し、その小さな問題を解くことで問題全体を解く**

``` javascript
const reverse = ([x, ...rest]) => x === undefined ? [] : [...reverse(rest), x]

const max = ([x, ...rest]) => rest.length === 0 ? x : (x > max(rest) ? x: max(rest))
```

「式と演算子の組み合わせは式」なので、三項演算子は式であり、全てを式の組み合わせで表す関数型プログラミングと相性がいい！

`reduce`は**データ構造(配列)を単一の値(数、配列、オブジェクト)にまとめるということを行っており、畳み込み演算と呼ばれる。**


#### 関数型プログラミングでの記述力

##### 型
式と文の違いとして型の有無がある。

式には型があり、文には型がない。式に型があるということは、関数にも型があるということ！

##### 参照透過性と副作用
「入力が同じであれば出力も同じになる」という性質を**参照透過性**という。参照透過でない関数としては、例えば関数街の何かの変数の値や関数が呼ばれた時刻などによってその関数の結果が異なるものがある。

関数とは、引数を受け取って値を返すものであり、それ以外の振る舞いは**副作用**と呼ばれる。副作用とはファイルの読み書きやAPIあるいはデータベースなどとの通信も含むのであり、実際のアプリケーションを作成する際には副作用を完全に無くすことはできない。

重要なのは、引数を受け取って計算結果を返すだけの関数（参照透過性を持ち、副作用のない**純粋関数**）と、副作用を伴う関数を明確に分離すること！

再帰の際にメモ化が可能なのは、関数の参照透過性による！


#### 関数型プログラミングと宣言的UI
関数型プログラミングは「何をするか」ではなく「何であるか」を示すパラダイム。関数型プログラミングはより広く「宣言的プログラミング」というカテゴリに属するパラダイムであり、これはUIの表示と親和性が高い。

つまり、どのように表示するのかという命令を与えるのではなく、表示するものが何であれば良いかを宣言する、ということ。このような考え方を特に**宣言的（declarative）UI**という。

### クロージャを理解する
jsの関数が持つ内部的な仕組みの１つであり、コードから直接参照したり操作したりはできない。

#### クロージャとは
「定義時のコンテキストへの参照を持つ関数」のこと。ここでのコンテキストとはスコープチェーンともいう。要は関数の定義位置から見たその関数が参照可能な外部変数、と考えて差し支えない。

jsでは関数を作成すると裏側ではクロージャが作成される。また、その関数が消失するとクロージャも消失する。

jsの関数はクロージャでもある。

jsの関数が備える基本的な性質を組み合わせて使うと非常にパワフルなことができるようになる。例えば、関数内部の変数をプライベートメンバのように扱い、関数に状態を持たせて一種の記憶装置のような仕組みを作ることができる。

##### scope
jsのスコープには、グローバルスコープ、関数スコープ、ブロックスコープの３つがある。


##### Callオブジェクト
Callオブジェクト（アクティベーションオブジェクト）は関数が呼び出された時に自動的に生成されるオブジェクトで、プログラムから直接参照や操作はできない。

Callオブジェクトには関数が呼び出された時の引数や、関数内のローカル変数がプロパティとして記録されている。

##### スコープチェーン
Callオブジェクトの情報をもとに、スコープを遡って変数を探しにいく。

これがスコープチェーン！

##### 静的スコープ
jsの関数は静的スコープ。

このことがクロージャに面白い性質を持たせている。

``` javascript
const x = "global";

function f() {
    console.log(x);
}

f(); // => global

function g() {
    const x = "local";

    f(); // => global
}

g();
```

##### 入れ子型の巻数
関数はどこにでも持ち出せるが、あくまでも定義時のスコープで実行される。

``` javascript
const createCounte = function() {
    let cnt = 0;

    const show = function () {
        cnt = cnt + 1;
        console.log(cnt);
    };

    return show;
};

const counter = createCounter();
counter(); // =>1
counter(); // =>2
counter(); // =>3
```

cnt をどこから探すか。スコープチェーンを遡る。showのCallオブジェクト、createCounterのCallオブジェクト、グローバルオブジェクト。ここではcreateCounterで解決する。

関数showはグローバル変数counterに格納されているので、showは生存したままになる。そして、**静的スコープの性質により**、showが実行時に参照するスコープチェーンは定義時に決定されている。

createCounterのcallオブジェクトはこのスコープチェーンに含まれており、showが生きている間は破棄されずに常に参照可能な状態として残ることとなる。

結果、createCounterの実行が完了してもそのCallオブジェクトは生存しているという状態になり、このCallオブジェクトに登録されているcntもアクセス可能な状態として残り続ける！

jsの関数は、いかなる場所やタイミングで実行されようとも、定義時のコンテキストで実行される。

クロージャを利用したテクニックは「関数の性質を利用したテクニック」のこと

#### クロージャが活用されるケース
- グローバル変数を使わずに関数に「状態」を持たせる
- 関数を作る関数


``` javascript
const makeCounter = function(num) {
    let current = 0;

    return function () {
        current = cnt + num;
        console.log(current);
    };
};

const increment = makeCounter(1);
const decrement = makeCounter(-1);
```


## Github Actions

### What Is Github Actions
- [Events that trigger workflows](https://docs.github.com/ja/actions/using-workflows/events-that-trigger-workflows)

#### 構成要素
- Workflow
  - 1つ以上のジョブから構成
  - 1つのワークフローにつき、１つのYAMLファイル
  - トリガーとなるイベントが異なれば、ワークフローを別に用意する
- Job
  - １つ以上のステップから構成されるタスク定義
  - ジョブが分割されると、それぞれ別のランナーアプリケーションインスタンスで実行されるため、ジョブ間のデータ共有に注意する
- Step
  - ステップは、ジョブの中で実行される各タスクのこと
- Action
  - アクションは、ステップを構成する最小の構成要素

##### Action
jsアクション、Dockerコンテナアクション、Compositeアクション

##### Runner
Jobはランナーと呼ばれるアプリケーションにより実行される。なお、ランナーは2019年にOSSとして公開されている

[Github](https://github.com/actions/runner)

[自分のランナーをホストする](https://docs.github.com/ja/actions/hosting-your-own-runners)


```
$ git tag -a v0.0.1 -m "v0.0.1"
```

#### あれこれ
- [Actions cache examples](https://github.com/actions/cache)
- Github Environments は 2021/12 にリリースされた機能！
- IaC
  - CI/CD との組み合わせ
  - AWS CloudFormation
  - Google Cloud Deployment Manager
  - Azure Resource Manager
  - Terraform
  - Ansible
- やってみたいこと
  - Terraformを活用し、CI/CD経由でAWSにEC2を構築する

#### Github Actionsによる細かいタスクの自動化
GitHub Actioinsは、コードのビルド、テスト、リリースなどを自動化できるが、CI/CD専用の自動化ツールではない！！！

[Action Github-Scripts](https://github.com/actions/github-script)


labeler.yml: どのファイルの変更にどのラベルを付与するか。・

``` yml
# .github/labeler-config.yml
# kubernetes配下ファイル+サブフォルダ含む
kubernetes:
- kubernetes/**/*

# cloudformation配下のファイル
cloudformation:
- cloudformation/*

# terraform配下のファイル
terraform:
- terraform/*
```

``` yml
name: Labeler
on:
  pull_request:

jobs:
  label:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/labeler@v3
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          configuration-path: ".github/labeler-config.yml"
          sync-labels: true
```


## セキュリティキー
yubiKey

## リアルタイム通信を支える技術

TCPとUDPを同一のサーバで処理する設計は推奨されない。TCPとUDPを同一のサーバで処理するシステムでは、お互いの通信プロトコルが干渉し合うことで、パフォーマンスが著しく損なわれるから。

具体的には、TCPの影響でUDPがパケットロスを誘発しやすくなり、UDPが期待したパフォーマンスを出すことが困難になるため。TCPとUDPはその下のIP（Internet Protocol）レイヤを共有している

## 生成ディープラーニング

## DLの高速化

### 分散学習の種類
プログラムの並列化で重要となるのは「処理の分割単位」と「通信の有無」。前者は実装の難易度、後者は並列性能に関わってくる。通信処理はオーバーヘッドが大きいのでなるべく避けたいが、メモリ空間が異なるマシン間で情報を共有するには必要不可欠である。

#### データ並列
データ並列は、学習に使用するデータセット全体を分割して各マシンに分配する並列化手法。各マシンが全体のコピーを持つ。データセットが大きい場合に有効。

#### モデル並列
学習対象のモデルを分割して各マシンに分配する並列化手法。大規模モデルを扱う場合に有効。ただ、なかなか高い性能を得るのが難しい。オーバーヘッドも大きい。

### 分散学習の仕組み
ミニバッチ単位で学習結果の同期をとり、マシン間で学習効果を共有する


## UNIX

### テキスト前処理
- nkf
- tr -s "\n"
  - `echo pieeeeeeeen | tr -s e  # pien`
- dd

### POSIX の枠
これだけは守っておけば、全てのUNIX系システムで長く動作することをお互い保証しようという最低限の約束、それがIEEEによって定められたPOSIX（The Portable Operating System Interface）

POSIX では、APIとコマンドラインシェル、ユーティリティーなどのソフトウェア互換性が定められている。

bash は POSIX の上位互換。bash --posix とすることで、厳格に POSIX 準拠の機能だけに絞れる。

UNIX 系 OS に標準的に装備されている（されていてほしい）コマンドで、POSIX の枠を少しはみ出してもできるだけ多くのおシステムで動作して、できるだけ多くの言語や文字もサポートするため（bash も含めた）標準的なコマンドを GNU のプロジェクトが提供している。

最も基本的なツール類を含む GNU core utilities（coreutils）は、GNU オペレーティングシステムの基本的なファイル、シェル、およびテキスト操作ユーティリティです。

coreutils は、POSIX に完全に準拠しているわけではなく、一部を拡張している。

「定義された、反復できる、管理された」規律を定めるのが POSIX

一方で、その制約を少し緩めれば、やりたいことを少し早く実現できることがある。デファクトスタンダードが、IT産業の発展をさせてきた礎である。十分に普及している技術を採用するのも良い。**将来生じるかもしれない何かに備えるのは、機動力とトレードオフになることがある**。機敏な決断、能動的な実践力を追求する俊敏性は、解放と創造を促す。

トレードオフを理解し、適切な技術を採用する

