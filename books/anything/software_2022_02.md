## 何でも

### Policy as Code

#### ポリシーをコードで定義する。
問題提起：ポリシー自体の品質をどのように維持するか

ポリシーを宣言型の言語を使ってコードとして記述・管理するアプローチ。

メリット

- アップデートやデプロイに対して便利
- バージョン管理システムの利点
- CI/CD によるデプロイの自動化

#### しくみ
Policy as Code を実現するソリューションとして次のようなものがある

- Sentinel
- Open Policy Agent (OPA)

ポリシーエンジン


## js

### 関数
アロー関数の場合は、関数の定義場所で this が静的に決まるので、呼び出し方に左右されない。

例えば、グローバルに定義したアロー関数は、this が必ずグローバルオブジェクトを指す。

アロー関数にはシンプルに arguments がない。

引数名の重複を許していたが、アロー関数は許さない。

アロー関数には、関数名の重複も基本的にはない

アロー関数と関数式は、定義ごに呼び出す必要がある。

#### 使い分け
従来の関数とアロー関数の違いを踏まえ、どちらを使ったほうが良いだろうか。もしどちらも使う場合、どのような基準があるのだろうか。このテーマは議論が尽きず、絶対的に正しい結論がない！

特に理由がない場合、アロー関数が無難。アロー関数は関数としての最低限の機能を持ったシンプルな関数で、細かいことを気にせず書ける利点がある。

とくにコールバック関数に適している

``` javascript
const nums = [1, 2, 3, 4];
const even = nums.filter((n) => n % 2 === 0);
console.log(even);

// 従来の関数とコールバック関数
const even.filter(function (n) {
    return n % 2 === 0;
});
```

### 引数
引数の個数チェックがない。

足りないものは、undefined になる。

#### 値渡しとオブジェクト
オブジェクトの場合は少し特殊で、オブジェクトは値が共有される。


## 関数は第一球オブジェクトである
これは数値や文字列と同様に関数を変数に代入したり関数の引数に渡したりできることを意味する！

#### 値としての関数の挙動
``` javascript
const add = function(x, y) { return x + y; }

console.log(add(3, 4));
console.log(add);
```

#### 関数をオブジェクトのプロパティに入れる
関数が入ったプロパティのことをメソッドという。

#### 即時関数
計算後に sum という変数が残らないのが利点

``` javascript
const arr = [1, 2, 3, 4, 5];

const average = (() => {
    const sum = arr.reduce((a, b) => a + b);
    return sum / arr.length;
})
```

#### 第一級オブジェクトとしての関数を利用する

##### 高階関数の活用
higher-order function,

関数が第一級オブジェクトではない言語であっても似たようなことをするのは不可能ではなく、そのやり方は「Visitor パターン」や「Strategy パターン」などとして知られる。

高階関数に引数で渡した関数は**コールバック関数**と呼ばれる。

### JavaScriptで関数型プログラミングを理解する
関数型プログラミングとは、プログラミングにおけるパラダイムの一つ。しばしば別のパラダイムである「命令型プログラミング」と対比される。

#### 命令型プログラミングとは
命令型プログラミングとは、プログラムを書くときに「how」つまり「何を、どのようにするか」を書いていく考え方やスタイルのこと。

命令型プログラミングにおいては、**文（statement）と式（expression）**が存在する。

文とは、コンピュータが処理する１ステップのことで、if, switch, for, while などがある。

式とは、数字や文字列などのリテラル、変数、関数の呼び出し、あるいは式と演算子の組み合わせのこと。

文と式のうち、命令型プログラミングで重要なのは文の方。

#### 関数型プログラミング
関数型プログラミングは「what」すなわち「何であるか」を記述する。

関数型プログラミングでは全てが式。

関数型で配列の和を求める関数

``` javascript
const sum = (arr) => (arr.length === 0 ? 0 : arr[0] + sum(arr.slice(1)))
```

再帰（recursion）が関数型プログラミングでは重要となる。

どうやって計算すれば良いかという手順を指定する命令型プログラミングとは異なり、関数型プログラミングでは求めるものがなんであるかという定義そのものを宣言しなければならず、そのために再起的な記述が力を発揮する

そして、x === undefined ? 0 のような部分は**基底部（base condition, edge condition）**と呼ばれる。基底部とは、再起的な定義を行うことができないケース。

再起で関数を定義するときは、**問題を同じ構造を持つより小さな問題に再起的に分割し、その小さな問題を解くことで問題全体を解く**

``` javascript
const reverse = ([x, ...rest]) => x === undefined ? [] : [...reverse(rest), x]

const max = ([x, ...rest]) => rest.length === 0 ? x : (x > max(rest) ? x: max(rest))
```

「式と演算子の組み合わせは式」なので、三項演算子は式であり、全てを式の組み合わせで表す関数型プログラミングと相性がいい！

`reduce`は**データ構造(配列)を単一の値(数、配列、オブジェクト)にまとめるということを行っており、畳み込み演算と呼ばれる。**


#### 関数型プログラミングでの記述力

##### 型
式と文の違いとして型の有無がある。

式には型があり、文には型がない。式に型があるということは、関数にも型があるということ！

##### 参照透過性と副作用
「入力が同じであれば出力も同じになる」という性質を**参照透過性**という。参照透過でない関数としては、例えば関数街の何かの変数の値や関数が呼ばれた時刻などによってその関数の結果が異なるものがある。

関数とは、引数を受け取って値を返すものであり、それ以外の振る舞いは**副作用**と呼ばれる。副作用とはファイルの読み書きやAPIあるいはデータベースなどとの通信も含むのであり、実際のアプリケーションを作成する際には副作用を完全に無くすことはできない。

重要なのは、引数を受け取って計算結果を返すだけの関数（参照透過性を持ち、副作用のない**純粋関数**）と、副作用を伴う関数を明確に分離すること！

再帰の際にメモ化が可能なのは、関数の参照透過性による！


#### 関数型プログラミングと宣言的UI
関数型プログラミングは「何をするか」ではなく「何であるか」を示すパラダイム。関数型プログラミングはより広く「宣言的プログラミング」というカテゴリに属するパラダイムであり、これはUIの表示と親和性が高い。

つまり、どのように表示するのかという命令を与えるのではなく、表示するものが何であれば良いかを宣言する、ということ。このような考え方を特に**宣言的（declarative）UI**という。

### クロージャを理解する
jsの関数が持つ内部的な仕組みの１つであり、コードから直接参照したり操作したりはできない。

#### クロージャとは
「定義時のコンテキストへの参照を持つ関数」のこと。ここでのコンテキストとはスコープチェーンともいう。要は関数の定義位置から見たその関数が参照可能な外部変数、と考えて差し支えない。

jsでは関数を作成すると裏側ではクロージャが作成される。また、その関数が消失するとクロージャも消失する。

jsの関数はクロージャでもある。

jsの関数が備える基本的な性質を組み合わせて使うと非常にパワフルなことができるようになる。例えば、関数内部の変数をプライベートメンバのように扱い、関数に状態を持たせて一種の記憶装置のような仕組みを作ることができる。

##### scope
jsのスコープには、グローバルスコープ、関数スコープ、ブロックスコープの３つがある。


##### Callオブジェクト
Callオブジェクト（アクティベーションオブジェクト）は関数が呼び出された時に自動的に生成されるオブジェクトで、プログラムから直接参照や操作はできない。

Callオブジェクトには関数が呼び出された時の引数や、関数内のローカル変数がプロパティとして記録されている。

##### スコープチェーン
Callオブジェクトの情報をもとに、スコープを遡って変数を探しにいく。

これがスコープチェーン！

##### 静的スコープ
jsの関数は静的スコープ。

このことがクロージャに面白い性質を持たせている。

``` javascript
const x = "global";

function f() {
    console.log(x);
}

f(); // => global

function g() {
    const x = "local";

    f(); // => global
}

g();
```

##### 入れ子型の巻数
関数はどこにでも持ち出せるが、あくまでも定義時のスコープで実行される。

``` javascript
const createCounte = function() {
    let cnt = 0;

    const show = function () {
        cnt = cnt + 1;
        console.log(cnt);
    };

    return show;
};

const counter = createCounter();
counter(); // =>1
counter(); // =>2
counter(); // =>3
```

cnt をどこから探すか。スコープチェーンを遡る。showのCallオブジェクト、createCounterのCallオブジェクト、グローバルオブジェクト。ここではcreateCounterで解決する。

関数showはグローバル変数counterに格納されているので、showは生存したままになる。そして、**静的スコープの性質により**、showが実行時に参照するスコープチェーンは定義時に決定されている。

createCounterのcallオブジェクトはこのスコープチェーンに含まれており、showが生きている間は破棄されずに常に参照可能な状態として残ることとなる。

結果、createCounterの実行が完了してもそのCallオブジェクトは生存しているという状態になり、このCallオブジェクトに登録されているcntもアクセス可能な状態として残り続ける！

jsの関数は、いかなる場所やタイミングで実行されようとも、定義時のコンテキストで実行される。

クロージャを利用したテクニックは「関数の性質を利用したテクニック」のこと

#### クロージャが活用されるケース
- グローバル変数を使わずに関数に「状態」を持たせる
- 関数を作る関数


``` javascript
const makeCounter = function(num) {
    let current = 0;

    return function () {
        current = cnt + num;
        console.log(current);
    };
};

const increment = makeCounter(1);
const decrement = makeCounter(-1);
```


## Github Actions



