## テストについて

### 偽陽性と偽陰性

自動テストに期待すること: 「失敗することで、テスト対象の動きが予期せず変わったことをプログラマーに教えてくれる」

期待はずれの自動テストは、以下の２通りが考えられる。

- 失敗すべき時でない時に失敗してしまう: 偽陽性（false positive）
- 失敗すべき時に失敗しないこと: 偽陰性（false negative）

### 偽陽性

代表的な偽陽性のパターン２つ

- 脆いテスト
  - 変わりやすい画面レイアウトに依存したテスト
  - 変更のたびにメンテが必要となる
- 信頼不能テスト（flaky test）
  - 不安定で決定性のないテスト
  - E2E テストなどが代表例
    - サーバやネットワークの負荷によってタイムアウトしたり、
    - ブラウザが不安定でクリック要素出現の待ち時間を超えてしまったりと、
    - コード外の要因によってテスト結果が左右されること

### 偽陰性

代表的な偽陰性のパターン３つ

- 空振り
  - 実は実行されてなかった、とか
- カバレッジ不足
  - 書かれるべきテストが書かれてない
  - 実装レベルのカバレッジ不足
  - 仕様レベルのカバレッジ不足
    - そもそもコードが書かれてないので**可視化が難しく**手強い！
- テスト対象ロジックのテストコードへの漏れ出し
  - テストで期待値も同じロジックで算出してる場合など

成功しているテスト群を疑う姿勢が必要。

### 欠陥挿入

**テストコードのテスト、ではなく、テストコードのテストはプロダクトコードで行う！**

プロダクトコードに明らかな誤りを一時的に混入させ、その誤りをテストが検知できるかを確かめること。

### まとめ

偽陽性は、放置すると、テストの失敗に対して鈍感になったりしてまう。
偽陰性は、テストできていると思ったらできていない、静かで恐ろしい問題。

## データモデリング

いいデータモデルとは、モデリングの過程で、考慮されていない要求の穴やエッジケースの発見につながる！

### 良いデータモデルの条件

コンセプトが抽象化されたものを見える形に落とし込んだものがモデルであり、**何を同じとみなし、何を違うと判断する**か、が共通認識の鍵となる。

どう永続化するかは実装の詳細ですので、最終的な実装形態によらず、データモデルを記述する抽象レベルにおいて、業務で扱うデータやその関係性は全て表現しておかなければならない！

#### エンティティ

- １つのものである
- ほかのものとは区別されて独立している

１つの識別子と、それに関数従属する複数の属性。

『Data and Reality』によるエンティティの性質

- 単一性（Oneness）
- 同一性（Sameness）
- カテゴリ（Category）

エンティティの設計は、あいまいで主観的に、恣意的に定めなければならない場合が多くある。これは、「１つのもの」がはっきりとは定まらないため。

#### 何をソフトウェアで解決するか

問題領域と解決領域。

#### 概念と実装を区別する

データモデルの記述には、論理レベル、物理レベルがある。
論理レベルでは、データはどこに格納されるかは関心がない。そのデータが何であるかにフォーカスする。
物理レベルでは、データをどこにどのように格納するかを記述する。

基本は、まずは論理レベルでのデータモデルを作成する。

#### 「変更できること」に隠された要求

何かしらの情報が「変更できる」ことという要求の裏には、さまざまな業務イベントが隠されていることが多い！

**変更イベントを洗い出す**
ライフサイクルを持つエンティティに、日時などの変更された属性を持たせたい事態に遭遇したら、更新の鳥がとなるイベントについて関係者で議論する良い機会。

### イミュータブルデータモデル

イミュータビリティはシンプルさを維持するためのツールキットの１つ。
まずやることは、データをリソースとイベントに分類すること。

#### 「更新」が複雑さの源泉である

共有リソースを整理し、更新箇所や更新の発生するタイミングを、まずは明らかにすることが重要。

#### 複雑とは何か

[Simple Made Easy](https://www.youtube.com/watch?v=SxdOUGdseq4&ab_channel=StrangeLoopConference) - Simple と Easy は違う。

シンプルとは、あるものが１つの責務や１つの役割、１つの概念を持つこと。そのシンプルの対義語が複雑！

#### ２種類の複雑さ

Simple Made Easy では、１つのエンティティに複数の概念や役割をもたせることをやめましょう、という話をしている。
一方、このように設計すると、必然的に**エンティティの数が増える**。エンティティの数が増えるのを「複雑だぁ」と言って避ける人もいるが、それは記憶すべきものが増えるという認知的負荷の高まりからくる反応である。この２つの複雑さについて？

「Out of the tar pit」という論文では、複雑さには必須のものとそうでないものがあるとしている。エンティティの数の多さは、ある対象の業務が持つ生来的な複雑さを示しているので、業務がある限りなくすことはできない。

#### シンプル化のルール

- エンティティに複数の概念、役割、責務が混在しないように分割する
- エンティティをグルーピングして、一度に見るべき範囲を狭める

#### 事実は更新されてはならない

システムはモノ（リソース）とコト（イベント）に分類できるが、イベントは動かせない「事実」であり、イベントの属性として正確に記録すべし。また、**更新されてもならない！**

イベントはイミュータブルであるべきだが、リソースは設計の選択によっては変更もあり得る。

#### リソースとイベントの関係

社員というリソースエンティティは、「入社」イベントによって生成され、「出世」イベントによって変更され、「退職」イベントによって消滅する。

現実的には、イベントのデータ記録や保管にお金がかかるため、次のものを中心としてどのイベントを記録するかを検討することとなる。

- お金を生み出すもの
- 記録が残ってないとお金を失うリスクがあるもの

#### データと情報

DIKW ピラミッド（Data, Information, Knowledge, Wisdom）では次のように整理されている

- データ
  - Know nothing
  - 客観的な事実または観測
  - 未整理、未加工
- 情報
  - Know what
  - 意味と目的が与えられたデータ

**情報は主観的な意味を含み、必要なものは時間経過とともに変化していくかもしれない、という性質を持つ！**

### イミュータブルデータモデルの基本

**更新**に着目してエンティティを分類したり更新操作自体を排除させたりしていく。
全てのエンティティから変更日時を追い出すことができていれば、イミュータブルデータモデルとしてはひとまず完成！

#### エンティティの抽出

要求を文章化し、そこから動詞や名詞に下線を引いてみる。

> <u>発注担当者</u>が<u>受注リスト</u>をもとに、<u>商品</u>の<u>在庫</u>を<u>確認し</u>、在庫があれば商品を<u>注文者</u>の注文時の<u>送付先住所</u>に<u>発送する</u>。

これらがエンティティと属性の候補になる。

#### 単一性、同一性、カテゴリ

エンティティには境界の曖昧さを含むことが多々あり、これらを放置すると構造の複雑さに変貌する！

サブタイプを表現する。

#### エンティティ間の関連

エンティティが日時属性を持てばイベントであり、持たなければリソース！

日時属性とは、行為のなされた日時のこと！

#### １つの事実は１つの場所に

正規化の原則は One Fact in One Place である。

#### 全エンティティにつける登録日時と変更日時

**真っ当に設計したら、リソース、イベントのエンティティどちらにも、「登録日時」「変更日時」を属性として一律で持たせる意味はない！！**
持った方がいい、と感じることがあれば、設計ステップを見直すべき。。。

#### ライフサイクルに着目する

社員の中から防災管理者を任命するとして、「防災管理者フラグ」を持たせるのはダメそう。

社員自体の属性の変更と、防災管理者の任命/解任は別のイベントだし、ある社員が防災管理者かどうかを知りたいユースケースは、社員の他の属性を参照するものとは大抵別の場合だろう。したがって、防災管理者であるという属性を、ライフサイクルの異なる社員の他の属性と一緒にしておく必然性はない！

#### 非依存のリレーションシップは交差エンティティで

非依存（一方が存在しなくても、他方が存在し得るもの）の関係があれば、それは交差エンティティとして扱う。

また、時系列の逆転したイベントエンティティ間のリレーションシップも、交差エンティティで表現する！

また、リソースエンティティ間の関連は１つではなければならないという縛りはない！

### れい

記録すべき「事実」が何かということと、その「事実」に更新操作が入らないように設計する、という鉄則を死守す！

#### 過去や未来のデータを扱う

「世代」と呼ぶ。

- シングル世代テーブルパターン
  - 適応開始日及び適応終了日を属性として持たせる
- 有効世代ビューパターン
  - 最新のデータのみ参照できれば良い場合に有効
  - RDBMS なら、ビューやマテリアライズドビューを使う
- 世代バージョンタグ付けパターン
  - 全ての世代のデータを持っておいて、バージョンやタグで必要なものを指し示す
- アンチパターン
  - 削除フラグによる世代管理
    - サブタイプに任せるべし！

サブタイプがきちんと洗い出されているのは良い傾向で、構造の複雑さが可視化できてる。

#### 削除フラグを改善するぞ！

どれも「エンタープライズアプリケーションアーキテクチャパターン」に載っている

- 単一テーブル継承パターン
- 具象テーブル継承パターン
- クラステーブル継承パターン

### ドメインモデルへの応用

Domain Modeling made functional の本において、関数が多言語でドメインモデリングをどう進めればよいか書かれるなど、ドメインモデルは決してオブジェクト指向の専売特許ではない！

シンプルな型、すなわち複数の概念・責務が混在しない型を設計することが、ドメインモデリングにも重要。

**そもそも「ドメイン駆動設計」のサブタイトルは『ソフトウェアの核心にある複雑さに立ち向かう』である！**
つまり、複雑さを解消することこそがドメインモデルの第一義であり、ドメイン駆動設計のその他のテクニックはそれを実現するための手段に過ぎない、とも言える。

### リンク

- [システムの複雑さはどこから来るのか – Out of the tar pit を読む](https://tech.uzabase.com/entry/2021/05/20/141950)

  「ユーザーが、その言葉を聞いても、それがなんなのかわからないようなものは、すべて付随的と考えるべき」

## Flutter

### Tips

- Flutter のバージョン管理ツール
  - fvm

```sh
$ flutter doctor

$ flutter --version
Flutter 3.0.5 • channel stable • https://github.com/flutter/flutter.git
Framework • revision f1875d570e (7 weeks ago) • 2022-07-13 11:24:16 -0700
Engine • revision e85ea0e79c
Tools • Dart 2.17.6 • DevTools 2.12.2
```

https://github.com/kokoichi206/flutter-app/pull/2

## Web3

### 第一歩

#### Web3 とは

プライバシーを守りながら分権的に動作する新しい Web のあり方を、これからの社会のオペレーティングシステムのようなものとして。

Web3 の特徴として「分権性」と「トークンを基盤とする経済」の２つが挙げられる。

#### 分権性

システム側からの分権性とは、従来の Web の基幹を担ってきた組織・企業・政府などに頼ることなく、情報の公開や改変を信頼できる形で、管理者なしに実現できること
ユーザー側からの分権性とは、自らに関する情報をどこまで公開するかを自己決定できること。

そして、両方の観点における分権性を可能にする技術としてブロックチェーンが用いられる。

#### トークンを基盤とする経済

トークノミクス

> Web3 では、これまで扱いづらかった定性的な内容をも含む価値をブロックチェーンに基づくトークンという形で表現することで、経済的価値交換を可能にする

#### Web3 を支える技術

- ブロックチェーン
  - 電子署名とハッシュポインタを使用
  - 改竄検出が容易なデータ構造
  - 当該データをネットワーク上に分散する多数のノードに保持させる
- ブロックチェーンと web3
  - トラストのアーキテクチャ
  - スマートコントラクト
  - 台帳とトークン

#### Web におけるアーキテクチャの変遷

- Web 1
  - 1991-2004
  - ユーザは Web サイトと一体の存在
  - URL とハイパーリンクによる関係
- Web 2
  - ~2021
  - EC
  - プラットフォーム上のルールに基づく関係
- Web 3
  - ユーザーはブロックチェーン上のアカウントとして表現される

#### Web3 への Web2.5

Web3 のアーキテクチャを全面的に採用するのは、現時点では難しい、その課題は何か。

- ブロックチェーンへの書き込み速度が、これまでの Web2 におけるアプリケーションで求められるパフォーマンス要件を満たすことが難しいほど遅い
  - 書き込みにかかる手数料が高い
  - 解決策
    - レイヤ 2 ソリューション
      - 取引履歴をまとめて処理して手数料を下げる
    - Ethereum 自体のアップデート
      - [イーサリアムのビジョン](https://ethereum.org/ja/upgrades/vision/)
- 利便性に関する課題
  - フルノードで自ら構築・運用するのは、一般のユーザーにはコストが高すぎる
  - そこで、どこかのサービスが提供する Web API を使うこととなる
  - これは分権化の理想とはほど遠い！

Web2.5 として、応答性能が必要なデータに関しては従来通りの DB への書き込みで実現しつつ、トークノミクスの良さを！

### ブロックチェーン

#### 構成要素

- 暗号技術
- 暗号学的ハッシュ関数
- デジタル署名
- P2P ネットワーク
- ノード
- フルノード
- コンセンサスメカニズム
- マイニングとマイナー
  - PoW (Proof-of-Work)

DYOR (Do Your Own Research)

## 何か

### ドキュメンテーション術

- 書いた本人だけが理解している暗黙的な事柄を明文化する
- Design Doc
- **読者は誰なのかを、冒頭で書くと良いかも！**
- 日本語で書いていたものを、一旦 DeepL などにかけてみると、暗黙的に飛ばしていた主語が見つかることも！
- 日本語スタイルガイド

### OPA/Rego

ポリシーのコード化。

Policy as Code.

ポリシーとは、例えば以下のような、外部入出力や副作用を持たない純粋関数、と表現できる。

- ある DB には、管理者権限を持つユーザーのみアクセスできるべき
- IaaS で作成したインスタンスは、TCP のポート 443 のみ公開されるべき
- あるプロダクトのソースコードは、本番環境にデプロイする前に必ず 2 人以上にレビューされるべき

#### 何が嬉しいか

- 機械可読性
- 再現性
  - 自然言語のような曖昧さがなくなる
- テスト
- バージョン管理やレビュー
- デプロイの自動化

#### [OPA](https://github.com/open-policy-agent/opa)

[説明](https://www.openpolicyagent.org/)の部分かっこいい

### ReDoS

#### マッチの実装方法

- DFA
  - Deterministic Finite-state Automaton
  - マッチ対象の文字列の長さに比例する時間でマッチが終了することが保証されている
  - ReDoS が起こらない
  - メモリ消費量や実行速度の点で、多くの場合は VM よりも不利
- VM
  - Virtual Machine

#### VM 型のバックトラック

`^(a|a)*$` は、a が 30 個で 10 億回以上のバックトラックが発生し、ReDoS に繋がる。

#### ReDoS の原因

- 指数関数的な場合
  - `^(a|a)*$` や `^(a*)*$` などの表現
- 二乗的な場合
  - `^a*a*$`

#### 見た目で判断することの難しさ

- 同じ文字列でマッチの仕方が 2 通りある繰り返しが存在する
  - 指数関数的な場合
- 繰り返しの間の文字列で、それらの繰り返しを１周できる
  - 二乗的な場合

#### ReDoS 対策あれこれ

- セッション単位のタイムアウトの利用
- DFA 型のマッチ実装の利用
  - regexp-Go, regex-Rust, re2-C++ などの DFA 型のマッチ実装
  - 後方参照などの一部の拡張が利用できない
- 入力の長さの制限
- ReDoS 検出実装の利用
- そもそも正規表現を利用しない
- マッチ単位のタイムアウトの利用
  - Ruby 3.2 ~

Perl ではさまざまな最適化が行われている〜！

### FastAPI による Web API 開発

- レスポンス速度の評価が高い
- 型ヒントを活用して API 仕様中心に開発ができる

**定義した型情報をもとに OpenAPI Specificationi (旧 Swagger)のドキュメントを自動生成できる！**

### モニタリングの始め方

一定以上の信頼性のもとで、できるだけ素早く新機能を開発しリリースすることが目標！

SLO: Service Level Objective, サービスレベル目標
SLI: SErvice Level Indicator, サービスレベル指標

#### モニタリングに役だつシステム特性

- Observability: 可観測性
  - 出力からシステムの状態を推定できる特性
  - メトリクスやログ
- Controllability: 可制御性
  - システムを任意の状態に収束させる能力がある特性
  - スケールアウト

[SLO Docs の例](https://github.com/masayoshi634/web-db-press-vol.130/blob/main/docs/slo_docs.md)
