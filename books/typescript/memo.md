Programming TypeScript shows all the benefits of using a type system on top of JavaScript and provides deep insight into how to master the language.

TypeScript can help you eliminate bugs in your code and enable you to scale your code across more engineers than you could before.

Polymorphism is your best friend.

In practice, how correct your code is is up to you and your team.


## chap 1
- Type safety
  - Using types to prevent programs from doing invalid things.
- You will find yourself sketching out a program at the type level before you fill it in at the value level; you will think about edge cases as you design your program, not as an afterhought.

## chap 2

### The Compiler
Programs are files that contain a bunch of text written by you. That text is parsed by a special program called a compiler, which transforms it into an **abstract syntax tree (AST)**, a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate.

The compiler then converts that AST to a lower-level representation called **bytecode**. You can feed that bytecode into another program called a **runtime** to evaluate it and get a result.

So, when you run a program, what you're really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code.

Once again, the steps are:

1. Program is parsed into an AST.
2. AST is compiled to bytecode.
3. Bytecode is evaluated by the runtime.

Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to ... JavaScript code!

> After the TypeScript Compiler generates an AST for your program - but before it emits code - it typechecks your code.

1. TypeScript source -> TypeScript AST
2. AST is checked by typechecker
3. TypeScript AST -> JavaScript Source
4. JavaScript Source -> JavaScript AST
5. AST -> bytecode
6. Bytecode is evaluated by runtime

Steps 1-3 are done by TSC(TypeScript Compiler) and steps 4-6 are done by the JavaScript runtime that lives in your browser, NodeJS, or whatever JavaScript engine you're using.

inference magic

> In general, it is good style to let TypeScript infer as many types as it can for you, keeping explicitly typed code to a minimum.

TypeScript can't catch for you at compile time - things like stack overflows, broken network connections, and malformed user inputs - that will still result in runtime exceptions.

### setups
```sh
$ npm install --save-dev typescript tslint @types/node
```

tsconfig.json

```
{
  "compilerOptions": {
    "lib": ["es2015"],
    "target": "es2015",
    "module": "commonjs",
    "outDir": "dist",
    "strict": true
  },
  "include": [
    "src
  ]
}
```

## English

### Words
- aficionados
  - someone who is very interested in and enthusiastic about a particular subject: 
- nerd
  - engage in or discuss a technical field obsessively or with great attention to detail.

### sentences
- I'll wrap up with how to use TypeScript with your favorite frameworks, migrating your existing JavaScript project to TypeScript.
- What exactly do I mean when I say "safer"? What I am talking about, of course, is type safety.
- Don't get me wrong.
- When are errors surfaced?




